# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

""" This module provides a (functional) API to OpenGL ES 2.0.

There are multiple backend implementations of this API, available as
submodules of this module. One can use one of the backends directly,
or call `gl.use()` to select one. The backend system allow running
visualizations using Angle, WebGL, or other forms of remote rendering.
This is in part possible by the widespread availability of OpenGL ES 2.0.

All functions that this API provides accept and return Python arguments
(no ctypes is required); strings are real strings and you can pass 
data as numpy arrays. In general the input arguments are not checked
(for performance reasons). Each function results in exactly one OpenGL
API call, except when using the pyopengl backend.

The functions do not have docstrings, but most IDE's should provide you
with the function signature. For more documentation see
http://www.khronos.org/opengles/sdk/docs/man/

"""

# NOTE: modules in this package that start with one underscore are
# autogenerated, and should not be edited.

from __future__ import division

from ...util import config, logger

from ._constants import *  # noqa
from . import _main
from ._main import *  # noqa


# Variable that will hold the module corresponding to the current backend
current_backend = _main


# todo: we need a vispy.use(), e.g. webgl needs action both here and in app
def use(target='desktop'):
    """ Let Vispy use the target OpenGL ES 2.0 implementation.

    Parameters
    ----------
    target : str
        The target GL backend to use.

    Backends
    --------
    * desktop - Use desktop (i.e. normal) OpenGL.
    * pyopengl - Use pyopengl (for fallback and testing). 
    * angle - Use the Angle library to target DirectX (Windows only). (WIP)
    * mock - Dummy backend that can be useful for testing. (not yet available)
    * webgl - Send the GL commands to the browser. (not yet available)

    """
    target = target or 'desktop'

    # Get options
    target, _, options = target.partition(' ')
    debug = config['gl_debug'] or ('debug' in options)

    # Select modules to import names from
    try:
        mod = __import__(target, globals(), level=1)
    except ImportError as err:
        msg = 'Could not import gl target "%s":\n%s' % (target, str(err))
        raise RuntimeError(msg)

    # Apply
    global current_backend
    current_backend = mod
    _main.PROXY = mod.__dict__
    _copy_gl_functions(mod, globals(), debug)


def _copy_gl_functions(source, dest, debug=False):
    """ Inject all objects that start with 'gl' from the source
    into the dest. source and dest can be dicts or modules.
    """
    # Get dicts
    if not isinstance(source, dict):
        source = source.__dict__
    if not isinstance(dest, dict):
        dest = dest.__dict__
    # Make selection of names
    funcnames = [name for name in source.keys() if name.startswith('gl')]
    for name in funcnames:
        func = source[name]
        if debug and name != 'glGetError':
            func = _make_debug_wrapper(name, func)
        dest[name] = func


def _arg_repr(arg):
    """ Get a useful (and not too large) represetation of an argument.
    """
    r = repr(arg)
    max = 40
    if len(r) > max:
        if hasattr(arg, 'shape'):
            r = 'array:' + 'x'.join([repr(s) for s in arg.shape])
        else:
            r = r[:max-3] + '...'
    return r


def _make_debug_wrapper(funcname, func):
    """ Create a wrapper function around the given function. For debug
    purposes.
    """
    def cb(*args, **kwds):
        argstr = ', '.join(list(map(_arg_repr, args)) +
                           ['%s=%s' % (key, _arg_repr(val))
                            for (key, val) in kwds.items()])
        logger.debug("%s(%s)" % (funcname, argstr))
        ret = func(*args, **kwds)
        logger.debug(" <= %s" % repr(ret))
        try:
            check_error(funcname)
        except Exception:
            print("%s(%s)" % (funcname, argstr))
            raise
        return ret
    return cb


def check_error(when='periodic check'):
    """ Check this from time to time to detect GL errors.

    Parameters
    ----------
    when : str
        Shown in the exception to help the developer determine when
        this check was done.
    """

    errors = []
    while True:
        err = glGetError()
        if err == GL_NO_ERROR:
            break
        errors.append(err)
    if errors:
        msg = ', '.join([repr(ENUM_MAP.get(e, e)) for e in errors])
        err = RuntimeError('OpenGL got errors (%s): %s' % (when, msg))
        err.errors = errors
        err.err = errors[-1]  # pyopengl compat
        raise err


def _has_pyopengl():
    try:
        from OpenGL import GL  # noqa
    except Exception:
        return False
    else:
        return True


def _requires_pyopengl():
    import numpy as np
    return np.testing.dec.skipif(not _has_pyopengl(), 'Requires PyOpenGL')


# Load default gl backend
# todo: this would be a slow version, but gloo keeps some function
# objects when importing and we need to be able to switch gl backend
# *after* gloo is loaded

from . import desktop as default_backend
_main.PROXY = default_backend.__dict__
