# -*- coding: utf-8 -*-
# Copyright (c) 2014, Vispy Development Team.
# Distributed under the (new) BSD License. See LICENSE.txt for more info.

from __future__ import division

from ..util.event import EmitterGroup, Event
from .shaders import StatementList
from .. import gloo

"""
Uses for VisualView:
    * Display visual with multiple transforms
    * Display visual with multiple clipping geometries
    * Display with solid color for picking
    * Display with filtered colors for anaglyph
    
"""

class BaseVisual(object):
    """
    Abstract class representing a drawable object.

    At a minimum, Visual subclasses should extend the draw() method. 

    Events:

    update : Event
        Emitted when the visual has changed and needs to be redrawn.
    bounds_change : Event
        Emitted when the bounds of the visual have changed.

    """


class VisualView(BaseVisual):
    """Represents a view on a Visual object.
    
    Visuals may be rendered multiple times in a single frame and each rendering
    may have its own transformations or other modifications. For example, a
    3D model might be viewed simultaneously in multiple orientations, and
    Visuals that implement picking will be drawn differently when checking for
    mouse collisions.
    
    Each type of rendering requires its own shader program and GL state 
    options. To implement this, each VisualView contains its own program and 
    GL state.
    """
    def __init__(self, visual, key):
        self._visual = visual
        self._view_key = key
        self._program = visual.program.add_view(key)
        self._gl_state = {'preset': None}

    @property
    def program(self):
        return self._program

    @property
    def transform_system(self):
        pass
    
    


class Visual(VisualView):
    """Visual represents a single drawable object, defined by a single shader
    program. 
    
    Visuals may be viewed many times in different ways
    """
    
    vertex_code = None
    fragment_code = None
    
    def __init__(self):
        self._visible = True
        self.events = EmitterGroup(source=self,
                                   auto_connect=True,
                                   update=Event,
                                   bounds_change=Event,
                                   )
        self._views = [self]
        self._gl_state = {'preset': None}
        self._filters = set()
        self._hooks = {}
        self._program = MultiProgram(self.vertex_code, self.fragment_code)
        
        VisualView.__init__(self, self)

    @property
    def program(self):
        return self._program

    def set_gl_state(self, preset=None, **kwargs):
        """Completely define the set of GL state parameters to use when drawing
        this visual.
        """
        self._gl_state = kwargs
        self._gl_state['preset'] = preset
    
    def update_gl_state(self, *args, **kwargs):
        """Modify the set of GL state parameters to use when drawing
        this visual.
        """
        if len(args) == 1:
            self._gl_state['preset'] = args[0]
        elif len(args) != 0:
            raise TypeError("Only one positional argument allowed.")
        self._gl_state.update(kwargs)
        
    def _update(self):
        """
        This method is called internally whenever the Visual needs to be 
        redrawn. By default, it emits the update event.
        """
        self.events.update()

    def draw(self, transforms):
        """
        Draw this visual now.
        The default implementation calls gloo.set_state().
        
        This function is called automatically when the visual needs to be drawn
        as part of a scenegraph, or when calling 
        ``SceneCanvas.draw_visual(...)``. It is uncommon to call this method 
        manually.
        
        The *transforms* argument is a TransformSystem instance that provides 
        access to transforms that the visual
        may use to determine its relationship to the document coordinate
        system (which provides physical measurements) and the framebuffer
        coordinate system (which is necessary for antialiasing calculations). 
        
        Vertex transformation can be done either on the CPU using 
        Transform.map(), or on the GPU using the GLSL functions generated by 
        Transform.shader_map().
        """
        gloo.set_state(**self._gl_state)

    def bounds(self, mode, axis):
        """ Return the (min, max) bounding values describing the location of
        this node in its local coordinate system.
        
        Parameters
        ----------
        mode : str
            Describes the type of boundary requested. Can be "visual", "data",
            or "mouse".
        axis : 0, 1, 2
            The axis along which to measure the bounding values, in
            x-y-z order.
        
        Returns
        -------
        None or (min, max) tuple. 
        
        Notes
        -----
        This is used primarily to allow automatic ViewBox zoom/pan.
        By default, this method returns None which indicates the object should 
        be ignored for automatic zooming along *axis*.
        
        A scenegraph may also use this information to cull visuals from the
        display list.
        
        """
        return None

    def update(self):
        """
        Emit an event to inform listeners that this Visual needs to be redrawn.
        """
        self.events.update()

    def _get_hook(self, shader, name):
        """Return a FunctionChain that Filters may use to modify the program.
        
        *shader* should be "frag" or "vert"
        *name* should be "pre" or "post"
        """
        assert name in ('pre', 'post')
        key = (shader, name)
        if key in self._hooks:
            return self._hooks[key]
        
        prog = getattr(self, '_program', None)
        if prog is None:
            raise NotImplementedError("%s shader does not implement hook '%s'"
                                      % key)
        hook = StatementList()
        if shader == 'vert':
            prog.vert[name] = hook
        elif shader == 'frag':
            prog.frag[name] = hook
        self._hooks[key] = hook
        return hook
        
    def attach(self, filter):
        """Attach a Filter to this visual. 
        
        Each filter modifies the appearance or behavior of the visual.
        """
        filter._attach(self)
        self._filters.add(filter)
        
    def detach(self, filter):
        """Detach a filter.
        """
        self._filters.remove(filter)
        filter._detach(self)


class CompoundVisual(BaseVisual):
    """Visual consisting entirely of sub-visuals.
    """
